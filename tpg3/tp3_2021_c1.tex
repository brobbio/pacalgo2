\documentclass{book}
\usepackage{subfiles}
\usepackage{amsmath,thmtools}
\usepackage[paper=a4paper, left=1.5cm, right=1.5cm, bottom=1.5cm, top=3.5cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{selinput}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{latexsym}
\usepackage{lastpage}
\usepackage{aed2-symb,aed2-itef,aed2-tad,aed2-diseno}
\usepackage{algorithmicx, algpseudocode, algorithm}
\usepackage[colorlinks=true, linkcolor=blue]{hyperref}
\usepackage{calc}

%% ========== Para escribir pseudo ==========
%\usepackage{algorithm}
%\usepackage[noend]{algpseudocode}  % "noend" es para no mostrar los endfor, endif
\algrenewcommand\alglinenumber[1]{\tiny #1:}  % Para que los numeros de linea del pseudo sean pequeños
\renewcommand{\thealgorithm}{}  % Que no aparezca el numero luego de "Algorithm"
\floatname{algorithm}{ }    % Entre {  } que quiero que aparezca en vez de "Algorithm"

% traducciones
% \algrenewcommand\algorithmicwhile{\textbf{mientras}}
% \algrenewcommand\algorithmicdo{\textbf{hacer}}
% \algrenewcommand\algorithmicreturn{\textbf{devolver}}
% \algrenewcommand\algorithmicif{\textbf{si}}
% \algrenewcommand\algorithmicthen{\textbf{entonces}}
% \algrenewcommand\algorithmicfor{\textbf{para}}
%%=========================================================

% Comandos para cositas de complejidad

\newcommand{\bigO}{\mathcal{O}} 
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Rpos}{\mathbb{R}_{>0}}
\newcommand{\eqdef}{\overset{\mathrm{def}}{=}}
\newcommand{\eqprop}{\overset{\mathrm{prop}}{=}}

\newcommand{\asignar}[2]{$#1 \gets #2$}

\begin{document}

    \pagestyle{plain}

    \begin{Interfaz}

        \textbf{se explica con}: \tadNombre{Mapa}

        \textbf{géneros}: \TipoVariable{mapa}.

        \Titulo{Operaciones básicas de mapa}

            \InterfazFuncion{NuevoMapa}{\In{largo}{nat}, \In{alto}{nat}, \In{inicio}{coordenada}, \In{llegada}{coordenada}, \In{fantasmas}{conj(coordenada)}, \In{paredes}{conj(coordenada)}, \In{chocolates}{conj(coordenada)}, \Out{m}{mapa}}{bool}%
            {$ (res = (inicio \neq llegada \wedge todosEnRango(paredes \cup fantasmas \cup chocolates \cup \{inicio, llegada\}, largo, alto) \wedge \{inicio, llegada\} \cap (fantasmas \cup paredes) = \emptyset \wedge disjuntosDeAPares(paredes, fantasmas, chocolates))) \wedge_L res \implies_{L} m \igobs nuevoMapa(largo, alto,inicio,llegada,paredes,fantasmas,chocolates)$ )}%
            [$O(chocolates + fantasmas + paredes)$]
            [Genera un nuevo mapa]
            [-]

            \InterfazFuncion{distConFantasmasMásCercano}{\In{m}{mapa}, \In{posición}{coordenada}}{nat}%
            { res = distConFantasmasMásCercano(fantasmas(m), posición) }%
            [$O(n)$]
            [Devuelve la distancia con el fantasma más cercano]
            [-]

            \InterfazFuncion{enRango}{\In{m}{mapa}, \In{posición}{coordenada}}{bool}%
            {$res$ = enRango(posición, largo(m), alto(m))}%
            [$O(n)$]
            [Devuelve true si la posición se encuentra en rango]
            [-]

            \InterfazFuncion{chocolates}{\In{map}{mapa}}{conj(coordenada)}%
            {$res$ = chocolates(map)}%
            [$O(n)$]
            [Devuelve el conjunto de chocolates del mapa]
            [-]

            \InterfazFuncion{paredes}{\In{map}{mapa}}{conj(coordenada)}%
            {$res$ = paredes(map)}%
            [$O(n)$]
            [Devuelve el conjunto de paredes]
            [-]

            \InterfazFuncion{inicio}{\In{map}{mapa}}{coordenada}%
            {$res$ = inicio(map)}%
            [$O(1)$]
            [Devuelve la coordenada de inicio del mapa]
            [-]

            \InterfazFuncion{llegada}{\In{map}{mapa}}{coordenada}%
            {$res$ = llegada(map)}%
            [$O(1)$]
            [Devuelve la coordenada de llegada del mapa]
            [-]

    \end{Interfaz}

    \textbf{Representación}

    mapa se representa con $mp$

    %donde $mp$ es tupla($matriz$: secu(secu(tupla($fantasma$: bool, $peligrosa$: bool, $pared$: bool, $inicio$: bool, $llegada$: bool))), $chocolates$: conj(coordenada))

    donde $casillero$ es tupla($fantasma$: bool, $peligrosa$: bool, $pared$: bool, $inicio$: bool, $llegada$: bool)

    donde $columna$ es array[0...$ancho$] de casillero

    donde $mp$ es tupla($matriz$: array[0...$alto$] de columna, $chocolates$: conj(coordenada), $alto$: nat, $ancho$: nat)

    %donde $mp$ es tupla($matriz$: array[0...$alto$] de (array[0...$ancho$] de laCosa), $chocolates$: conj(coordenada))

    %donde $mp$ es tupla($matriz$: array[array[0...$ancho$], array[0...$ancho$] ... $alto$]  de (array[0...$ancho$] de laCosa), $chocolates$: conj(coordenada))

    \textbf{Invariante de representación}

        \tadOperacion{Rep}{mp}{boolean}{}

        \tadAxioma{Rep($e$)}{True $\iff$ 
            ($\forall$ i: nat)(0 $\leq$ i $\leq$ $e.alto$) $\implies_L$ ( \\
                \qquad \text{} ($\forall$ j: nat)(0 $\leq$ j $\leq$ $e.ancho$) $\implies_L$ ( \\
                        \text{}\qquad\qquad ($\beta$($e.matriz[i][j].inicio$) $+$ \\
                        \text{}\qquad\qquad $\beta$($e.matriz[i][j].llegada$) $+$ \\
                        \text{}\qquad\qquad $\beta$($e.matriz[i][j].pared$) $+$ \\
                        \text{}\qquad\qquad $\beta$($e.matriz[i][j].fantasma$) $+$ \\
                        \text{}\qquad\qquad $\beta$($\langle$ $i$, $j$ $\rangle$ $\in$ $e.chocolates$) $=$ $1$) $\wedge$ \\
                        \text{}\qquad\quad ($e.matriz[i][j].peligrosa$ $\implies_L$ ($\exists$ $n$,$m$: nat)($0$ $\leq$ $n$ $\leq$ $e.alto$ $\wedge$ $0$ $\leq$ $m$ $\leq$ $e.ancho$) $\wedge_L$ \\
                        \text{}\qquad\qquad ($e.matriz[n][m].fantasma$ $\wedge$ distancia($\langle$$i$,$j$$\rangle$, $\langle$$n$,$m$$\rangle$) $\leq$ $3$)) $\wedge$ \\
                        \text{}\qquad\quad (($\forall$ $n$,$m$ : nat) (0 $\leq$ $n$ $\leq$ $alto$ $\wedge$ 0 $\leq$ $m$ $\leq$ $ancho$ ) $\implies_L$ \\ 
                        \text{}\qquad\qquad (($e.matriz[n][m].inicio$ $\wedge$ $e.matriz[i][j].inicio$) $\implies$ $n=i$ $\wedge$ $m=j$ )) $\wedge$ \\ 
                        \text{}\qquad\quad (($\forall$ $n$,$m$ : nat) (0 $\leq$ $n$ $\leq$ $alto$ $\wedge$ 0 $\leq$ $m$ $\leq$ $ancho$ ) $\implies_L$ \\ 
                        \text{}\qquad\qquad (($e.matriz[n][m].llegada$ $\wedge$ $e.matriz[i][j].llegada$) $\implies$ $n=i$ $\wedge$ $m=j$ ))
                )
            )  }

        $ $

    \textbf{Función de abstracción}

        \tadOperacion{Abs}{mp $e$}{Mapa}{Rep($e$)}

        ($\forall$ $e$ : mp) Abs($e$) $\igobs$ $m$: mapa | largo($m$) = $e.largo$ $\wedge$ \\
            \text{}\qquad ancho($m$) = $e.ancho$ $\wedge$ \\
            
            \text{}\qquad chocolates($m$) = $e.chocolates$ $\wedge$ \\
            \text{}\qquad ($\forall$ i: nat)(0 $\leq$ i $\leq$ $e.alto$) $\implies_L$ ( \\
                \text{}\qquad\quad ($\forall$ j: nat)(0 $\leq$ j $\leq$ $e.ancho$) $\implies_L$ ( \\
                \text{}\qquad\quad $e.matriz[i][j].inicio = inicio(m)$ $\wedge$ \\
                \text{}\qquad\quad $e.matriz[i][j].llegada = llegada(m)$ $\wedge$ \\
                \text{}\qquad\quad $e.matriz[i][j].fantasma \iff \langle i,j \rangle \in fantasmas(m) \wedge $ \\
                \text{}\qquad\quad $e.matriz[i][j].paredes \iff \langle i,j \rangle \in paredes(m) \wedge $ \\
                \text{}\qquad\quad $e.matriz[i][j].peligrosa \iff distConFantasmasMásCercano(fantasmas(m), \langle i,j \rangle) \leq 3$))


            % long(e.elem) = capacidad($c$) $\wedge$ \\
            % tamaño(verCola($c$)) $\igobs$ \IF e.fin $\geq$ e.inicio THEN e.fin-e.inicio ELSE e.inicio + (long(e.elem) - e.fin) FI $\wedge$ \\
            % \IF e.fin $\geq$ e.inicio THEN
            %     ($\forall$ i: nat)(e.inicio $\leq$ i $\leq$ e.fin) $\implies_L$ e.elem[i] = proximo(desencolarNveces(verCola($c$,e.fin - i))) $\wedge$ \\
            %     ($\forall$ i: nat)(0 $\leq$ i $\leq$ e.inicio $\vee$ e.fin $\leq$ i $<$ long(e.elem)) $\implies_L$ (e.elem[$i$] = 0?) $\wedge$
            % ELSE 
            %     ($\forall$ i: nat)(e.inicio $\leq$ i $\leq$ e.fin) $\implies_L$ (e.elem[$i$] = 0?) $\wedge$ \\
            %     ($\forall$ i: nat)(0 $\leq$ i $\leq$ e.inicio $\vee$ e.fin $\leq$ i $<$ long(e.elem)) $\implies_L$ (e.elem[$i$] = proximo(desencolarNveces(verCola($c$, {\IF e.fin $leq$ i < long(e.elem) THEN (i - e.fin) ELSE (long(e.elem) - e.fin) + i FI}))))
            % FI

        % \tadOperacion{desencolarNveces}{cola $c$, nat $n$}{ColaAcotada}{$n$ < tamaño($c$)}
        % \tadAxioma{desencolarNveces($c$,$n$)}{ \IF pred($n$)=0? THEN $c$ ELSE desencolarNveces(desencolar($c$), pred($n$)) FI }

    \newpage

    \begin{Interfaz}

        \textbf{se explica con}: \tadNombre{Partida}

        \textbf{géneros}: \TipoVariable{partida}.

        \Titulo{Operaciones básicas de partida}

            \InterfazFuncion{nuevaPartida}{\In{m}{mapa}}{partida}%
            {$res$ = nuevaPartida(m)}%
            [$O(n)$]
            [Genera una nueva partida]
            [-]

            \InterfazFuncion{mover}{\Inout{p}{partida}, \In{d}{dirección}}{}%
            [$p_0$ = $p$]
            {$p$ = mover($p_0$, $d$)}%
            [$O(n)$]
            [Mueva la posición del jugador un casillero]
            [-]

            \InterfazFuncion{ganó?}{\In{p}{partida}}{bool}%
            {$res$ = ganó?($p$)}%
            [$O(n)$]
            [Devuelve true si el jugador gano la partida]
            [-]

            \InterfazFuncion{perdió?}{\In{p}{partida}}{bool}%
            {$res$ = perdió?($p$)}%
            [$O(n)$]
            [Devuelve true si el jugador perdio la partida]
            [-]

            \InterfazFuncion{jugador}{\In{p}{partida}}{coordenada}%
            {$res$ = perdió?($p$)}%
            [$O(n)$]
            [Devuelve la posición del jugador]
            [-]

            \InterfazFuncion{cantMov}{\In{p}{partida}}{nat}%
            {$res$ = cantMov($p$)}%
            [$O(n)$]
            [Devuelve la cantidad de movimientos del jugador]
            [-]

    \end{Interfaz}

    \textbf{Representación}

    partida se representa con $pt$

    donde $pt$ es tupla($mapa$: mp, $jugador$: coordenada, $chocolates$: conj(chocolates), $cantMov$: nat, $inmunidad$: nat)

    \newpage

    \begin{Interfaz}

        \textbf{se explica con}: \tadNombre{Fichín}

        \textbf{géneros}: \TipoVariable{fichin}.

        \Titulo{Operaciones básicas de fichin}

        \InterfazFuncion{nuevoFichin}{\In{m}{mapa}}{fichin}%
        {$res$ = nuevoFichin($m$)}%
        [$O(n)$]
        [Genera un fichín]
        [-]

        \InterfazFuncion{nuevaPartida}{\Inout{f}{fichin}, \In{j}{jugador}}{bool}%
        [$f_0$ = $f$]
        {$res$ = $\neg$alguienJugando?($f$) $\wedge_L$ $res$ $\implies_L$ $f$ = nuevaPartida($f_0$, $j$) }%
        [$O(n)$]
        [Inicia una nueva partida]
        [-]

        \InterfazFuncion{mover}{\Inout{f}{fichin}, \In{d}{dirección}}{bool}%
        [$f_0$ = $f$]
        {$res$ = alguienJugando?($f$) $\wedge_L$ $res$ $\implies_L$ $f$ = mover($f_0$, $d$) }%
        [$O(n)$]
        [Mueve en la dirrección indicada]
        [-]

        \InterfazFuncion{verRanking}{\In{f}{fichin}}{ranking}%
        {$res$ = ranking($f$)}%
        [$O(n)$]
        [Devuelve el ranking del fichin]
        [-]

        \InterfazFuncion{objetivo}{\In{f}{fichin}, \Out{o}{tupla<jugador, nat>}}{res}%
        {($res$ = alguienJugando?($f$) $\wedge$ def?(jugadorActual($f$), ranking($f$))) $\wedge_L$ $res$ $\implies_L$ $o$ = objetivo($f$) }%
        [$O(n)$]
        [Devuelve una tupla con el oponente y su puntaje]
        [-]

    \end{Interfaz}

    \textbf{Representación}

    partida se representa con $fch$

    donde $fch$ es tupla($mapa$: mp, $alguienJugando$: bool, $jugadorActual$: string, $partidaActual$: pt, $ranking$: dicc(string, nat))

\end{document}
