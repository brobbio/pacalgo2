\documentclass{book}
\usepackage{subfiles}
\usepackage{amsmath,thmtools}
\usepackage[paper=a4paper, left=1.5cm, right=1.5cm, bottom=1.5cm, top=3.5cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{selinput}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{latexsym}
\usepackage{lastpage}
\usepackage{aed2-symb,aed2-itef,aed2-tad,aed2-diseno}
\usepackage{algorithmicx, algpseudocode, algorithm}
\usepackage[colorlinks=true, linkcolor=blue]{hyperref}
\usepackage{calc}

%% ========== Para escribir pseudo ==========
%\usepackage{algorithm}
%\usepackage[noend]{algpseudocode}  % "noend" es para no mostrar los endfor, endif
\algrenewcommand\alglinenumber[1]{\tiny #1:}  % Para que los numeros de linea del pseudo sean pequeños
\renewcommand{\thealgorithm}{}  % Que no aparezca el numero luego de "Algorithm"
\floatname{algorithm}{ }    % Entre {  } que quiero que aparezca en vez de "Algorithm"

% traducciones
% \algrenewcommand\algorithmicwhile{\textbf{mientras}}
% \algrenewcommand\algorithmicdo{\textbf{hacer}}
% \algrenewcommand\algorithmicreturn{\textbf{devolver}}
% \algrenewcommand\algorithmicif{\textbf{si}}
% \algrenewcommand\algorithmicthen{\textbf{entonces}}
% \algrenewcommand\algorithmicfor{\textbf{para}}
%%=========================================================

% Comandos para cositas de complejidad

\newcommand{\bigO}{\mathcal{O}} 
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Rpos}{\mathbb{R}_{>0}}
\newcommand{\eqdef}{\overset{\mathrm{def}}{=}}
\newcommand{\eqprop}{\overset{\mathrm{prop}}{=}}

\newcommand{\asignar}[2]{$#1 \gets #2$}

\begin{document}

    \pagestyle{plain}

    \begin{Interfaz}

        \textbf{se explica con}: \tadNombre{Mapa}

        \textbf{géneros}: \TipoVariable{mapa}.

        \Titulo{Operaciones básicas de mapa}

            \InterfazFuncion{NuevoMapa}{\In{largo}{nat}, \In{alto}{nat}, \In{inicio}{coordenada}, \In{llegada}{coordenada}, \In{fantasmas}{conj(coordenada)}, \In{paredes}{conj(coordenada)}, \In{chocolates}{conj(coordenada)}, \Out{m}{mapa}}{bool}%
            {$ (res = (inicio \neq llegada \wedge todosEnRango(paredes \cup fantasmas \cup chocolates \cup \{inicio, llegada\}, largo, alto) \wedge \{inicio, llegada\} \cap (fantasmas \cup paredes) = \emptyset \wedge disjuntosDeAPares(paredes, fantasmas, chocolates))) \wedge_L res \implies_{L} m \igobs nuevoMapa(largo, alto,inicio,llegada,paredes,fantasmas,chocolates)$ )}%
            [$O(chocolates + fantasmas + paredes)$]
            [Genera un nuevo mapa]
            [-]

            \InterfazFuncion{esCasilleroPeligroso}{\In{m}{mapa}, \In{posición}{coordenada}}{res}%
            { res = distConFantasmasMásCercano(fantasmas(m), posición) $\leq$ 3 }%
            [$O(1)$]
            [Devuelve true si el casillero es peligroso, es peligroso si existe un fantasma con distancia $\leq 3$ respecto a la posción]
            [-]

            \InterfazFuncion{enRango}{\In{m}{mapa}, \In{posición}{coordenada}}{bool}%
            {$res$ = enRango(posición, largo(m), alto(m))}%
            [$O(1)$]
            [Devuelve true si la posición se encuentra en rango]
            [-]

            \InterfazFuncion{cantChocolates}{\In{map}{mapa}}{nat}%
            {$res$ = \#(chocolates(map))}%
            [$O(c)$]
            [Devuelve la cantidad de chocolates en el mapa]
            [-]

            \InterfazFuncion{esPared}{\In{map}{mapa}, \In{posición}{coordenada}}{bool}%
            {$res$ = true $\iff$ $posición$ $\in$ paredes(map)}%
            [$O(1)$]
            [Devuelve el conjunto de paredes]
            [-]

            \InterfazFuncion{inicio}{\In{map}{mapa}}{coordenada}%
            {$res$ = inicio(map)}%
            [$O(1)$]
            [Devuelve la coordenada de inicio del mapa]
            [-]

            \InterfazFuncion{llegada}{\In{map}{mapa}}{coordenada}%
            {$res$ = llegada(map)}%
            [$O(1)$]
            [Devuelve la coordenada de llegada del mapa]
            [-]

    \end{Interfaz}

    \newpage

    \textbf{Representación}

    mapa se representa con $mp$

    $ $

    donde $casillero$ es tupla($fantasma$: bool, \\
        \text{}\qquad\quad $peligrosa$: bool, \\
        \text{}\qquad\quad $pared$: bool, \\
        \text{}\qquad\quad $idChocolate$: int)

    $ $

    donde $columna$ es array[0...$largo$] de casillero

    $ $

    donde $mp$ es tupla($matriz$: array[0...$alto$] de columna, \\
        \text{}\qquad\quad \#$chocolates$: nat, \\
        \text{}\qquad\quad $alto$: nat, \\
        \text{}\qquad\quad $largo$: nat, \\
        \text{}\qquad\quad $inicio$: coordenada, \\
        \text{}\qquad\quad $llegada$: coordenada)

    $ $

    \textbf{Invariante de representación}

        \tadOperacion{Rep}{mp}{boolean}{}

        \tadAxioma{Rep($e$)}{True $\iff$
            (0 $\leq$ $e.inicio_1$ $\leq$ $e.largo$ $\wedge$ 0 $\leq$ $e.inicio_2$ $\leq$ $e.alto$ ) $\wedge$ \\
            (0 $\leq$ $e.llegada_1$ $\leq$ $e.largo$ $\wedge$ 0 $\leq$ $e.llegada_2$ $\leq$ $e.alto$ ) $\wedge$ \\
            ($e.inicio$ $\neq$ $e.llegada$) $\wedge$ \\
            ($\forall$ i: nat)(0 $\leq$ i $\leq$ $e.largo$) $\implies_L$ ( \\
                \qquad \text{} ($\forall$ j: nat)(0 $\leq$ j $\leq$ $e.alto$) $\implies_L$ ( \\
                        \text{}\qquad\quad ($\beta$($e.matriz[i][j].pared$) $+$ \\
                            \text{}\qquad\qquad $\beta$($e.matriz[i][j].fantasma$) $+$ \\
                            \text{}\qquad\qquad $\beta$($0$ $\leq$ $e.matriz[i][j].idChocolate$ $<$ $e.\#chocolates$) $\leq$ $1$) $\wedge$ \\
                        \text{}\qquad\quad (($\forall$ $n$: $\Nat$)($0$ $\leq$ $n$ $<$ $e.\#chocolates$)\\ 
                        \text{}\qquad\qquad    ($\exists!$ $i$,$j$: $nat$ )( $0$ $\leq$ $i$ $\leq$ $e.largo$ $\wedge$ $0$ $\leq$ $j$ $\leq$ $e.alto$ ) $\wedge_L$ \\
                        \text{}\qquad\qquad\quad    ( $e.matriz[i][j].chocolates$ $=$ $n$ )) $\wedge$ \\
                        \text{}\qquad ($e.matriz[i][j].peligrosa$ $\implies_L$ ($\exists$ $n$,$m$: nat)($0$ $\leq$ $n$ $\leq$ $e.largo$ $\wedge$ $0$ $\leq$ $m$ $\leq$ $e.alto$) $\wedge_L$ \\
                        \text{}\qquad\quad ($e.matriz[n][m].fantasma$ $\wedge$ distancia($\langle$$i$,$j$$\rangle$, $\langle$$n$,$m$$\rangle$) $\leq$ $3$)))\\
                )}

        $ $

    \textbf{Función de abstracción}

        \tadOperacion{Abs}{mp\ $e$}{Mapa}{Rep($e$)}

        ($\forall$ $e$ : mp) Abs($e$) $\igobs$ $m$: mapa | largo($m$) = $e.largo$ $\wedge$ \\
            \text{}\qquad alto($m$) = $e.alto$ $\wedge$ \\
            \text{}\qquad \#(chocolates($m$)) = $e.\#chocolates$ $\wedge$ \\
            \text{}\qquad $e.inicio = inicio(m)$ $\wedge$ \\
            \text{}\qquad $e.llegada = llegada(m)$ $\wedge$ \\
            \text{}\qquad ($\forall$ i: nat)(0 $\leq$ i $\leq$ $e.largo$) $\implies_L$ ( \\
                \text{}\qquad\quad ($\forall$ j: nat)(0 $\leq$ j $\leq$ $e.alto$) $\implies_L$ ( \\
                \text{}\qquad\quad $e.matriz[i][j].fantasma \iff \langle i,j \rangle \in fantasmas(m) \wedge $ \\
                \text{}\qquad\quad $e.matriz[i][j].paredes \iff \langle i,j \rangle \in paredes(m) \wedge $ \\
                \text{}\qquad\quad $0 \leq e.matriz[i][j].chocolate < e.\#chocolates \iff \langle i,j \rangle \in chocolates(m) \wedge $ \\
                \text{}\qquad\quad $e.matriz[i][j].peligrosa \iff distConFantasmasMásCercano(fantasmas(m), \langle i,j \rangle) \leq 3$))

    \newpage

    \begin{Interfaz}

        \textbf{se explica con}: \tadNombre{Partida}

        \textbf{géneros}: \TipoVariable{partida}.

        \Titulo{Operaciones básicas de partida}

            \InterfazFuncion{nuevaPartida}{\In{m}{mapa}}{partida}%
            {$res$ = nuevaPartida(m)}%
            [$O(c)$, c = \#chocolates]
            [Genera una nueva partida]
            [-]

            \InterfazFuncion{mover}{\Inout{p}{partida}, \In{d}{dirección}}{}%
            [$p_0$ = $p$]
            {$p$ = mover($p_0$, $d$)}%
            [$O(1)$]
            [Mueva la posición del jugador un casillero]
            [-]

            \InterfazFuncion{ganó?}{\In{p}{partida}}{bool}%
            {$res$ = ganó?($p$)}%
            [$O(1)$]
            [Devuelve true si el jugador gano la partida]
            [-]

            \InterfazFuncion{perdió?}{\In{p}{partida}}{bool}%
            {$res$ = perdió?($p$)}%
            [$O(1)$]
            [Devuelve true si el jugador perdio la partida]
            [-]

            \InterfazFuncion{jugador}{\In{p}{partida}}{coordenada}%
            {$res$ = perdió?($p$)}%
            [$O(1)$]
            [Devuelve la posición del jugador]
            [-]

            \InterfazFuncion{cantMov}{\In{p}{partida}}{nat}%
            {$res$ = cantMov($p$)}%
            [$O(1)$]
            [Devuelve la cantidad de movimientos del jugador]
            [-]

    \end{Interfaz}

    \newpage

    \textbf{Representación}

    partida se representa con $pt$

    donde $pt$ es tupla($mapa$: mp, \\
        \text{}\qquad\quad$jugador$: coordenada, \\
        \text{}\qquad\quad$chocolates$: array[0...c] de bool, \\
        \text{}\qquad\quad$cantMov$: nat, \\
        \text{}\qquad\quad$inmunidad$: nat, \\
        \text{}\qquad\quad$gano$: bool, \\
        \text{}\qquad\quad$perdio$: bool)

    $ $ 

    \textbf{Funciones auxiliares}

    \tadOperacion{distancia}{coordenada, coordenada}{nat}{}
    \tadOperacion{distanciaMinima}{coordenada, conj(coordenada)}{bool}{}
    \tadOperacion{chocolatesSinComer}{pt}{conj(coordenada)}{}

    $ $

    \tadAxioma{distancia($x$, $y$)}{|$+x_1$ - $+y_1$| $+$ |$+x_2$ - $+y_2$|}
    \tadAxioma{distanciaMinima($j$, $c$)}{\IF \#($c$) = 1 THEN distancia($j$, dameUno($c$)) ELSE mín(distancia($j$, dameUno($c$)),distanciaMinima($j$, sinUno($c$))) FI}
    \tadAxioma{distanciaMinima($e$)}{Esta función devuelve el conjunto de coordenadas de chocolates en la $e.mapa.matriz$ cuyo Id en el array de la partida ($e.chocolates$) aun estan en true}

    $ $

    \textbf{Invariante de representación}

    \tadOperacion{Rep}{pt}{boolean}{}

    \tadAxioma{Rep($e$)}{True $\iff$ 
            ($e.mapa.EnRango$($e.mapa$,$e.jugador$) $\wedge$ \\
            \text{}\quad $long(e.chocolates) = e.mapa.\#chocolates $) $\wedge_L$ \\
            \text{}\quad $e.cantMov$ $=$ $0$ $\implies$ \\
            \text{}\qquad $e.mapa.inicio$ $=$ $jugador$ $\wedge$ $e.chocolates$ $=$ $e.mapa.chocolates$ $-$ $jugador$ $\wedge$ \\
            \text{}\qquad\quad \IF $e.chocolates[e.mapa.matriz[e.jugador_1][e.jugador_2].chocolate]$ THEN $e.inmunidad$ $=$ 10 ELSE $e.inmunidad$ $=$ $0$ FI $\wedge$\\
            \text{}\quad $\neg$($e.chocolates[e.mapa.matriz[e.jugador_1][e.jugador_2].chocolate]$) $\wedge$ \\
            \text{}\quad $e.inmunidad$ $=$ $10$ $\implies$ $0 \leq e.mapa.matriz[e.jugador_1][e.jugador_2].chocolate < e.mapa.\#chocolates$ $\wedge$ \\
            \text{}\quad $e.inmunidad$ $\leq$ 10 - distanciaMinima($jugador$, chocolatesSinComer($e$)) $\wedge$ \\
            \text{}\quad $e.gano$ $\iff$ $jugador$ = $e.mapa.llegada$ $\wedge$ \\
            \text{}\quad $e.perdio$ $\iff$ $e.inmunidad$ $=$ $0$ $\wedge$ $e.mapa.distConFantasmasM\acute{a}sCercano$($e.mapa$, $e,jugador$) $\leq$ $3$ \\
        }

    $ $

    \textbf{Función de abstracción}

        \tadOperacion{Abs}{pt\ $e$}{partida}{Rep($e$)}

        ($\forall$ $e$ : pt) Abs($e$) $\igobs$ $p$: partida | mapa(p) = $e.mapa$ $\wedge$ \\
            \text{}\quad\qquad jugador($p$) = $e.jugador$ $\wedge$ \\
            \text{}\quad\qquad chocolates($p$) = chocolatesSinComer($e$) $\wedge$ \\
            \text{}\quad\qquad cantMov($p$) = $e.cantMov$ $\wedge$ \\
            \text{}\quad\qquad inmunidad($p$) = $e.inmunidad$ $\wedge$ \\
            \text{}\quad\qquad ganó?($p$) = $e.gano$ $\wedge$ \\
            \text{}\quad\qquad perdió?($p$) = $e.perdio$

    \newpage

    \begin{Interfaz}

        \textbf{se explica con}: \tadNombre{Fichín}

        \textbf{géneros}: \TipoVariable{fichin}.

        \Titulo{Operaciones básicas de fichin}

        \InterfazFuncion{nuevoFichin}{\In{m}{mapa}}{fichin}%
        {$res$ = nuevoFichin($m$)}%
        [$O(?)$]
        [Genera un fichín]
        [-]

        \InterfazFuncion{nuevaPartida}{\Inout{f}{fichin}, \In{j}{jugador}}{bool}%
        [$f_0$ = $f$]
        {$res$ = $\neg$alguienJugando?($f$) $\wedge_L$ $res$ $\implies_L$ $f$ = nuevaPartida($f_0$, $j$) }%
        [$O(c)$]
        [Inicia una nueva partida]
        [-]

        \InterfazFuncion{mover}{\Inout{f}{fichin}, \In{d}{dirección}}{bool}%
        [$f_0$ = $f$]
        {$res$ = alguienJugando?($f$) $\wedge_L$ $res$ $\implies_L$ $f$ = mover($f_0$, $d$) }%
        [$O(|J|)$]
        [Mueve en la dirrección indicada]
        [-]

        \InterfazFuncion{verRanking}{\In{f}{fichin}}{ranking}%
        {$res$ = ranking($f$)}%
        [$O(1)$]
        [Devuelve el ranking del fichin]
        [-]

        \InterfazFuncion{objetivo}{\In{f}{fichin}, \Out{o}{tupla<jugador, nat>}}{res}%
        {($res$ = alguienJugando?($f$) $\wedge$ def?(jugadorActual($f$), ranking($f$))) $\wedge_L$ $res$ $\implies_L$ $o$ = objetivo($f$) }%
        [$O(log_2\ n)$]
        [Devuelve una tupla con el oponente y su puntaje]
        [-]

    \end{Interfaz}

    \newpage

    \textbf{Representación}

    partida se representa con $fch$

    $ $

    donde $fch$ es tupla($mapa$: mp, \\
        \text{}\qquad\quad$alguienJugando$: bool, \\
        \text{}\qquad\quad$jugadorActual$: string, \\
        \text{}\qquad\quad$partidaActual$: pt, \\
        \text{}\qquad\quad$ranking$: dicc(string, nat))

    $ $

    \textbf{Invariante de representación}

    \tadOperacion{Rep}{fch}{boolean}{}

    \tadAxioma{Rep($e$)}{True $\iff$ \\
            \text{}\quad ($e.alguienJugando$ $\iff$ (longitud($e.jugadorActual$) $>$ 0 $\wedge$ $\neg$$e.partida.gano$ $\wedge$ $\neg$$e.partida.perdio$)) $\wedge$ \\
            \text{}\quad ($e.pt.gano$ $\implies$ \\
            \text{}\qquad def?($e.jugadorActual$, $e.ranking$) $\wedge_L$ \\
            \text{}\qquad\quad obtener($e.jugadorActual$, $e.ranking$) $\leq$ $e.partida.cantMov$) $\wedge$\\
            \text{}\quad ($e.mapa$ = $e.pt.mapa$)
        }

    $ $

    $ $

    \textbf{Función de abstracción}

        \tadOperacion{Abs}{fch\ $e$}{partida}{Rep($e$)}
        ($\forall$ $e$ : fch) Abs($e$) $\igobs$ $f$: fichin | mapa($f$) = $e.mapa$ $\wedge$ \\
            \text{}\quad\qquad alguienJugando($f$) = $e.alguienJugando$ $\wedge$ \\
            \text{}\quad\qquad ranking($f$) = $e.ranking$ $\wedge$ \\
            \text{}\quad\qquad $e.alguienJugando$ $\implies_L$ partidaActual($f$) = $e.partidaActual$ $\wedge$ \\
            \text{}\quad\qquad $e.alguienJugando$ $\implies_L$ jugadorActual($f$) = $e.jugadorActual$


\end{document}
