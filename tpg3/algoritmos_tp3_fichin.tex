\documentclass{book}
\usepackage{subfiles}
\usepackage{amsmath,thmtools}
\usepackage[paper=a4paper, left=1.5cm, right=1.5cm, bottom=1.5cm, top=3.5cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{selinput}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{latexsym}
\usepackage{lastpage}
\usepackage{comment}
\usepackage{aed2-symb,aed2-itef,aed2-tad,aed2-diseno}
\usepackage{algorithmicx, algpseudocode, algorithm}
\usepackage[colorlinks=true, linkcolor=blue]{hyperref}
\usepackage{calc}

%% ========== Para escribir pseudo ==========
%\usepackage{algorithm}
%\usepackage[noend]{algpseudocode}  % "noend" es para no mostrar los endfor, endif
\algrenewcommand\alglinenumber[1]{\tiny #1:}  % Para que los numeros de linea del pseudo sean pequeños
\renewcommand{\thealgorithm}{}  % Que no aparezca el numero luego de "Algorithm"
\floatname{algorithm}{ }    % Entre {  } que quiero que aparezca en vez de "Algorithm"

% traducciones
% \algrenewcommand\algorithmicwhile{\textbf{mientras}}
% \algrenewcommand\algorithmicdo{\textbf{hacer}}
% \algrenewcommand\algorithmicreturn{\textbf{devolver}}
% \algrenewcommand\algorithmicif{\textbf{si}}
% \algrenewcommand\algorithmicthen{\textbf{entonces}}
% \algrenewcommand\algorithmicfor{\textbf{para}}
%%=========================================================

% Comandos para cositas de complejidad

\newcommand{\bigO}{\mathcal{O}} 
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Rpos}{\mathbb{R}_{>0}}
\newcommand{\eqdef}{\overset{\mathrm{def}}{=}}
\newcommand{\eqprop}{\overset{\mathrm{prop}}{=}}

\newcommand{\asignar}[2]{$#1 \gets #2$}

\begin{document}

\begin{Algoritmos}


\medskip
	
 \Titulo{Algoritmos de Fichin}
  	\medskip
  
\begin{algorithm}[H]{\textbf{iNuevoFichin}(\In{m}{mapa}) $\to$ $res$ : fichin}
    	\begin{algorithmic}[1]
			 \State $res \gets \langle m, False, NULL, NULL, vacio \rangle$ \Comment $\Theta(1)$

			\medskip
			\Statex
			\underline{Complejdad:} $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iNuevaPartida}(\Inout{f}{fichin}, \In{a}{jugador}) $\to$ $res$ : $bool$}
	\begin{algorithmic}
	        \State $res\gets False$
	       \If{$\neg f.alguienJugando$}
			 \State $f.jugadorActual \gets jugador$ 				\Comment $\Theta(1)$
			 \State $f.alguienJugando \gets True$ 				\Comment $\Theta(1)$
             \State $f.partidaActual \gets partida.iNuevaPartida(f.mapa)$ 				\Comment $\bigO(c)$
             \State $res\gets True$
             \EndIf
			\medskip
			\Statex
			\underline{Complejdad:} $\bigO(c)$
			\Statex
			\underline{Justificación:} La complejidad de este algoritmo es igual a la complejidad de $iNuevaPartida$, que es $\bigO(c)$, con $c = \#chocolates$. 
    	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{iMover}(\Inout{f}{fichin}, \In{d}{direccion}) $\to$ $res$ : $bool$}
	\begin{algorithmic}[1]
	        \If{$f.alguienJugando$}
			 \State partida.iMover(f.partidaActual, d)	\Comment $\Theta(1)$
			 \State $res\gets True$
			 \If{partida.iGanó?(f.partidaActual)}	\Comment $\bigO(1)$
			 \If{def?(f.jugadorActual, f.ranking)}\Comment{$\bigO(|J|)$}
			 \If{obtener(f.jugadorActual, f.ranking) $>$ partida.iCantMov(f.partidaActual)} \Comment{$\bigO(|J|)$} \\
			 \qquad\qquad definir(f.jugadorActual, partida.iCantMov(f.partidaActual), f.ranking)\Comment{$\bigO(|J|)$} \EndIf
		   \Else\hspace{0.05cm} definir(f.jugadorActual, partida.iCantMov(f.partidaActual), f.ranking)\Comment{$\bigO(|J|)$}\EndIf
		     \EndIf
			 \Else
			 \State $res\gets False$	\Comment $\Theta(1)$
			\EndIf 
			 


			\medskip
			\Statex \underline{Complejidad:} $\bigO(|J|)$ si se realiza un movimiento que finaliza la partida
			\Statex \underline{Justificación:} El diccionario se implementa con un trie, que tiene $\bigO(|J|)$ como complejidad de def?, acceder a significado y definir.
    	\end{algorithmic}
\end{algorithm}
	

\begin{algorithm}[H]{\textbf{iVerRanking}(\In{f}{fichin}) $\to$ $res$ : $dicc$}
	\begin{algorithmic}[1]
			 \State $res \gets f.ranking$	 \Comment $\Theta(1)$
    
			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}	


\begin{algorithm}[H]{\textbf{iObjetivo}(\In{f}{fichin}, \In{j}{jugador}) $\to$ $res$ : $\langle jugador, nat\rangle$}
	\begin{algorithmic}[1]

			 
			 \State $i \gets 0$\Comment $\Theta(1)$
			 \State $C \gets obtenerClavesTrie(f.ranking)$\Comment $\Theta(J)$
			 \State $S \gets \emptyset$ \Comment $\Theta(1)$
			 \While{$i < long(C)-1$}			
			 	\If{$obtener(C[i], f.ranking)<obtener(jugador, f.ranking)$}		\Comment $\bigO(|J|)$
			 	\State $Ag(C[i], S)$ \Comment{$\Theta(1)$}
			 	\EndIf
				\State $i \gets i + 1$		\Comment $\Theta(1)$
			 \EndWhile
			 \If{$\emptyset$?($S$)}
			 \State $res \gets \langle jugador, obtener(f.ranking, jugador)\rangle$	\Comment $\Theta(1)$
			 \Else
			 \State $max \gets obtener(f.ranking, S[0])$ \Comment{$\bigO(|J|)$}
			 \State $maxJugador \gets S[0]$\Comment $\Theta(1)$
			 \State $j \gets 0$
			 \While{$j<long(S)$}
			 \If{$obtener(f.ranking,S[j])\geq max$}\Comment $\Theta(|J|)$
			 \State $max\gets obtener(f.ranking, S[j])$\Comment $\Theta(|J|)$
			 \State $maxJugador\gets S[j]$\Comment $\Theta(1)$
			 \EndIf
			 \State $j\gets j+1$
			 \EndWhile
			 \State $res \gets \langle maxJugador, max\rangle$
			 \EndIf
			\medskip
			\Statex \underline{Complejidad:} $\sum_{k\in J}\bigO(|J|)+\bigO(|J|)+\sum_{k\in S}\bigO(|J|)=\bigO(|J|*J)$
			\Statex \underline{Justificación:} Los conjuntos $C,S$ son implementados con una lista enlazada para que insertar elementos sea $\bigO(1)$.
    	\end{algorithmic}
\end{algorithm}	

\Titulo{Módulo Diccionario Trie($\kappa$, $\sigma$)}

El módulo Diccionario Trie provee un diccionario básico en el que se puede definir, borrar, y testear si una clave está definida en tiempo $\bigO(|J|)$, donde $J$ es la cantidad de elementos del diccionario y $|J|=\max_{n\in J}{|n|}$. 

Para describir la complejidad de las operaciones, vamos a llamar $copy(k)$ al costo de copiar el elemento $k \in \kappa \cup \sigma$ y $equal(k_1, k_2)$ al costo de evaluar si dos elementos $k_1, k_2 \in \kappa$ son iguales (i.e., $copy$ y $equal$ son funciones de $\kappa \cup \sigma$ y $\kappa \times \kappa$ en $\mathbb{N}$, respectivamente).\footnote{Nótese que este es un abuso de notación, ya que no estamos describiendo $copy$ y $equal$ en función del tamaño de $k$.  A la hora de usarlo, habrá que realizar la traducción.}

\begin{Interfaz}

  \textbf{parámetros formales}\hangindent=2\parindent\\
  \parbox{1.7cm}{\textbf{géneros}}$\kappa,\sigma$\\
  \parbox[t]{1.7cm}{\textbf{función}}\parbox[t]{.5\textwidth-\parindent-1.7cm}{%
    \InterfazFuncion{$\bullet = \bullet$}{\In{k_1}{$\kappa$}, \In{k_2}{$\kappa$}}{bool}
    {$res \igobs (k_1 = k_2)$}
    [$\Theta(equal(k_1, k_2))$]
    [función de igualdad de $\kappa$'s]
  }%
  \parbox[t]{1.7cm}{\textbf{función}}\parbox[t]{.5\textwidth-\parindent-1.7cm}{%
    \InterfazFuncion{Copiar}{\In{k}{$\kappa$}}{$\kappa$}
    {$res \igobs k$}
    [$\Theta(copy(k))$]
    [función de copia de $\kappa$'s]
  }\\[2ex]
  \parbox[t]{1.7cm}{\textbf{función}}\parbox[t]{.5\textwidth-\parindent-1.7cm}{%
    \InterfazFuncion{Copiar}{\In{s}{$\sigma$}}{$\sigma$}
    {$res \igobs s$}
    [$\Theta(copy(s))$]
    [función de copia de $\sigma$'s]
  }

  \textbf{se explica con}: \tadNombre{Diccionario$(\kappa, \sigma)$}, \tadNombre{Iterador Bidireccional(tupla($\kappa,\sigma$))}.

  \textbf{géneros}: \TipoVariable{dicc$(\kappa, \sigma)$}, \TipoVariable{itDicc($\kappa, \sigma$)}.

  \Titulo{Operaciones básicas de diccionario}

  \InterfazFuncion{Vacío}{}{dicc$(\kappa,\sigma)$}%
  {$res$ $\igobs$ vacio}%
  [$\Theta(1)$]
  [genera un diccionario vacío.]

  \InterfazFuncion{Definir}{\Inout{d}{dicc($\kappa,\sigma$)}, \In{k}{$\kappa$}, \In{s}{$\sigma$}}{}
  [$d \igobs d_0$]
  {$d$ $\igobs$ definir($d, k, s$)}
  [$\bigO(|J|)$, donde $|J|$ es el nombre más largo entre los jugadores]
  [define la clave $k$ con el significado $s$ en el diccionario.]
  

  \InterfazFuncion{Definido?}{\In{d}{dicc($\kappa,\sigma$)}, \In{k}{$\kappa$}}{bool}
  {$res$ $\igobs$ def?($d$, $k$)}
  [$\bigO(|J|)$, donde $|J|$ es el nombre más largo entre los jugadores]
  [devuelve \texttt{true} si y sólo $k$ está definido en el diccionario.]

  \InterfazFuncion{Significado}{\In{d}{dicc($\kappa,\sigma$)}, \In{k}{$\kappa$}}{$\sigma$}
  [def?($d$, $k$)]
  {alias($res$ $\igobs$ Significado($d$, $k$))}
 [$\bigO(|J|)$, donde $|J|$ es el nombre más largo entre los jugadores]
  [devuelve el significado de una clave en el diccionario.]

  \InterfazFuncion{Borrar}{\Inout{d}{dicc($\kappa,\sigma$)}, \In{k}{$\kappa$}}{}
  [$d = d_0$ $\land$ def?($d$, $k$)]
  {$d$ $\igobs$ borrar($d_0, k$)}
   [$\bigO(|J|)$, donde $|J|$ es el nombre más largo entre los jugadores]
  [elimina la clave $k$ y su significado de $d$.]

   \InterfazFuncion{ObtenerClavesDelTrie}{\In{d}{dicc($\kappa,\sigma$)}}{conj($\kappa$)}
  {$res$ $\igobs$ claves($d$)}
  [$\Theta(J)$]
  [devuelve el conjunto de claves del diccionario.]

  \InterfazFuncion{\#Claves}{\In{d}{dicc($\kappa,\sigma$)}}{nat}
  {$res$ $\igobs$ \#claves($d$)}
  [$\Theta(1)$]
  [devuelve la cantidad de claves del diccionario.]

  \InterfazFuncion{Copiar}{\In{d}{dicc($\kappa,\sigma$)}}{dicc($\kappa,\sigma$)}
  {$res \igobs d$}
  [$\displaystyle\Theta\left(\sum_{k \in K}\left(copy(k) + copy(\text{significado}(k,d))\right)\right)$, donde $K$ $=$ claves($d$)]
  [genera una copia nueva del diccionario.]

  \InterfazFuncion{$\bullet = \bullet$}{\In{d_1}{dicc($\kappa,\sigma$)}, \In{d_2}{dicc($\kappa,\sigma$)}}{bool}
  {$res \igobs c_1 = c_2$}
  [$\displaystyle O\left(\sum_{\substack{k_1 \in K_1\\k_2\in K_2}}equal(\langle k_1,s_1\rangle, \langle k_2, s_2 \rangle)\right)$, donde $K_i$ $=$ claves($d_i$) y $s_i$ $=$ significado($d_i, k_i$), $i \in \{1,2\}$.]
  [compara $d_1$ y $d_2$ por igualdad, cuando $\sigma$ posee operación de igualdad.]
  []%no hay aliasing
  [{\parbox[t]{\textwidth-3cm}{%
    \InterfazFuncion{$\bullet = \bullet$}{\In{s_1}{$\sigma$}, \In{s_2}{$\sigma$}}{bool}
    {$res \igobs (s_1 = s_2)$}
    [$\Theta(equal(s_1, s_2))$]
    [función de igualdad de $\sigma$'s]
  }}]




\begin{comment}

\Titulo{Algoritmos del iterador}	
 
\begin{algorithm}[H]
	\begin{algorithmic}[1]
		\State \textbf{iCrearIt}(\In{l}{lst}) $\to$ $res$ : iter
		
			\State $res \gets \langle l.primero, l \rangle$ 	\Comment $\Theta(1)$
    	
		\medskip
		\Statex \underline{Complejidad:} $\Theta(1)$
    \end{algorithmic}
\end{algorithm}	

  
\begin{algorithm}[H]
	\begin{algorithmic}[1]
		\State \textbf{iCrearItUlt}(\In{l}{lst}) $\to$ $res$ : iter
		
			\State $res \gets \langle NULL, l \rangle$	\Comment $\Theta(1)$
    	
		\medskip
		\Statex \underline{Complejidad:} $\Theta(1)$
    \end{algorithmic}
\end{algorithm}	


\begin{algorithm}[H]
	\begin{algorithmic}[1]
		\State \textbf{iHaySiguiente}(\In{it}{iter}) $\to$ $res$ : $bool$
		
			\State $res \gets it.siguiente \neq NULL$	\Comment $\Theta(1)$

			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}
	
	
\begin{algorithm}[H]	
	\begin{algorithmic}[1]
		\State \textbf{iHayAnterior}(\In{it}{iter}) $\to$ $res$ : $bool$
		
			\State $res \gets it.siguiente \neq (it.lista\rightarrow primero)$	\Comment $\Theta(1)$

			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}
	
	
\begin{algorithm}[H]
	\begin{algorithmic}[1]
		\State \textbf{iSiguiente}(\In{it}{iter}) $\to$ $res$ : $\alpha$
		
			\State $res \gets (it.siguiente\rightarrow dato)$	\Comment $\Theta(1)$

			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}
	
	
\begin{algorithm}[H]{\textbf{iAnterior}(\In{it}{iter}) $\to$ $res$ : $\alpha$}
	\begin{algorithmic}[1]	
			\State $res \gets (SiguienteReal(it)\rightarrow anterior\rightarrow dato)$	\Comment $\Theta(1)$

			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}



\begin{algorithm}[H]
	\begin{algorithmic}[1]
		\State \textbf{iAvanzar}(\Inout{it}{iter})
		
			\State $it.siguiente \gets (it.siguiente\rightarrow siguiente)$	\Comment $\Theta(1)$
			\If{$it.siguiente = it.lista\rightarrow primero$}	\Comment $\Theta(1)$
				\State $it.siguiente \gets NULL$	
			\EndIf

			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
			\Statex \underline{Justificación:}  $\Theta(1)$ + $\Theta(1)$ = $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}
	
	
\begin{algorithm}[H]
	\begin{algorithmic}[1]
		\State \textbf{iRetroceder}(\Inout{it}{iter})
		
			\State $it.siguiente \gets (SiguienteReal(it)\rightarrow anterior)$	\Comment $\Theta(1)$

			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}
	
	
\begin{algorithm}[H]
	\begin{algorithmic}[1]
		\State \textbf{iEliminarSiguiente}(\Inout{it}{iter})
		
			\State $puntero(nodo) \ temp \gets it.siguiente$
			
			\State $(tmp\rightarrow siguiente\rightarrow anterior) \gets (tmp\rightarrow anterior)$
			\Comment{Reencadenamos los nodos // $\Theta(1)$}
			\State $(tmp\rightarrow anterior\rightarrow siguiente) \gets (tmp\rightarrow siguiente)$
		
			\If{$(tmp\rightarrow siguiente) = (it.lista\rightarrow primero)$}
			\Comment{Si borramos el último nodo, ya no hay siguiente // $\Theta(1)$}
				\State $it.siguiente \gets NULL$
			\Else
			\Comment{Sino, avanzamos al siguiente	// $\Theta(1)$}
				\State $it.siguiente \gets (tmp\rightarrow siguiente)$	
			\EndIf
			
			\If{$tmp = (it.lista\rightarrow primero)$}
			\Comment{Si borramos el primer nodo, hay que volver a setear el primero // $\Theta(1)$}
				\State $(it.lista\rightarrow primero) \gets it.siguiente$
			\EndIf
			
			\State $tmp \gets NULL$	 \Comment{Se libera la memoria ocupada por el nodo // $\Theta(1)$}
			\State $(it.lista\rightarrow longitud) \gets (it.lista\rightarrow longitud) - 1$

			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
			\Statex \underline{Justificación:} $\Theta(1)$ + $\Theta(1)$ + $\Theta(1)$ + $\Theta(1)$ + $\Theta(1)$ =  $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}

	
\begin{algorithm}[H]
	\begin{algorithmic}[1]
		\State \textbf{iEliminarAnterior}(\Inout{it}{iter})
		
			\State $Retroceder(it)$	\Comment $\Theta(1)$
			\State $EliminarSiguiente(it)$	\Comment $\Theta(1)$

			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
			\Statex \underline{Justificación:} $\Theta(1)$ + $\Theta(1)$ = $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
	\begin{algorithmic}[1]
		\State \textbf{iAgregarComoSiguiente}(\Inout{it}{iter}, \In{a}{$\alpha$})
		
			\State $AgregarComoAnterior(it, a)$		\Comment $\Theta(1)$
			\State $Retroceder(it)$	\Comment $\Theta(1)$

			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
			\Statex \underline{Justificación:} $\Theta(1)$ + $\Theta(1)$ = $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}
	

\begin{algorithm}[H]
	\begin{algorithmic}[1]
		\State \textbf{iAgregarComoAnterior}(\Inout{it}{iter}, \In{a}{$\alpha$})
		
			\State $puntero(nodo) \ sig \gets SiguienteReal(it)$
			\State $puntero(nodo) \ nuevo \gets $ \textbf{\&} $\langle a, NULL, NULL \rangle$ \Comment{Reservamos memoria para el nuevo nodo	// $\Theta(1)$}
			\If{$sig = NULL$}
			\Comment{Asignamos los punteros de acuerdo a si el nodo es el primero o no en la lista circular	// $\Theta(1)$}
				\State $(nuevo\rightarrow anterior) \gets nuevo$
				\State $(nuevo\rightarrow siguiente) \gets nuevo$
			\Else
				\State $(nuevo\rightarrow anterior) \gets (sig\rightarrow anterior)$
				\State $(nuevo\rightarrow siguiente) \gets sig$
			\EndIf
			
			\State $(nuevo\rightarrow anterior\rightarrow siguiente) \gets nuevo$ \Comment{Reencadenamos los otros nodos	// $\Theta(1)$}
			%\State $(nuevo\rightarrow anterior\rightarrow siguiente) \gets nuevo$ \Comment{Notar que no hay problema cuando nuevo es el único nodo	// $\Theta(1)$}
			
			\If{$it.siguiente = (it.lista\rightarrow primero)$}
			\Comment{Cambiamos el primero en caso de que estemos agregando el primero	// $\Theta(1)$}
				\State $(it.lista\rightarrow primero) \gets nuevo$
			\EndIf
			
			\State $(it.lista\rightarrow longitud) \gets (it.lista\rightarrow longitud) + 1$	\Comment $\Theta(1)$

			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
			\Statex \underline{Justificación:} $\Theta(1)$ + $\Theta(1)$ + $\Theta(1)$ +  $\Theta(1)$ =  $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}

	
\begin{algorithm}[H]
	\begin{algorithmic}
		\State \textbf{iSiguienteReal}(\In{it}{iter}) $\to$ $res$ : $puntero(nodo)$ \Comment{Esta es una operación privada que}
			
			\If{$it.siguiente = NULL$} \Comment{devuelve el siguiente como lista circular // $\Theta(1)$}
				\State $res \gets (it.lista\rightarrow siguiente)$
			\Else
				\State $res \gets it.siguiente$
			\EndIf
			
			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}
%    

\end{comment}
\end{Interfaz}
\end{Algoritmos}
\end{document}