\documentclass{book}
\usepackage{subfiles}
\usepackage{amsmath,thmtools}
\usepackage[paper=a4paper, left=1.5cm, right=1.5cm, bottom=1.5cm, top=3.5cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{selinput}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{latexsym}
\usepackage{lastpage}
\usepackage{comment}
\usepackage{aed2-symb,aed2-itef,aed2-tad,aed2-diseno}
\usepackage{algorithmicx, algpseudocode, algorithm}
\usepackage[colorlinks=true, linkcolor=blue]{hyperref}
\usepackage{calc}

%% ========== Para escribir pseudo ==========
%\usepackage{algorithm}
%\usepackage[noend]{algpseudocode}  % "noend" es para no mostrar los endfor, endif
\algrenewcommand\alglinenumber[1]{\tiny #1:}  % Para que los numeros de linea del pseudo sean pequeños
\renewcommand{\thealgorithm}{}  % Que no aparezca el numero luego de "Algorithm"
\floatname{algorithm}{ }    % Entre {  } que quiero que aparezca en vez de "Algorithm"

% traducciones
% \algrenewcommand\algorithmicwhile{\textbf{mientras}}
% \algrenewcommand\algorithmicdo{\textbf{hacer}}
% \algrenewcommand\algorithmicreturn{\textbf{devolver}}
% \algrenewcommand\algorithmicif{\textbf{si}}
% \algrenewcommand\algorithmicthen{\textbf{entonces}}
% \algrenewcommand\algorithmicfor{\textbf{para}}
%%=========================================================

% Comandos para cositas de complejidad

\newcommand{\bigO}{\mathcal{O}} 
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Rpos}{\mathbb{R}_{>0}}
\newcommand{\eqdef}{\overset{\mathrm{def}}{=}}
\newcommand{\eqprop}{\overset{\mathrm{prop}}{=}}

\newcommand{\asignar}[2]{$#1 \gets #2$}

\begin{document}

\begin{Algoritmos}


\medskip
	
 \Titulo{Algoritmos de Partida}
  	\medskip

    \begin{algorithm}[H]{\textbf{iNuevaPartida}(\In{m}{mapa}) $\to$ $res$ : $partida$}
        \begin{algorithmic}[1]
            \State $partida \gets <>$                               \Comment $\bigO(1)$
            \State $partida.mapa \gets m$                           \Comment $\bigO(1)$
            \State $partida.jugador \gets mapa.inicio(m)$           \Comment $\bigO(1)$
            \State $i \gets 0$                                      \Comment $\bigO(1)$
            \While{$i < mapa.cantChocolates(m)$}                    \Comment $\bigO(c)$
                \State $partida.chocolates[i] \gets true$           \Comment $\bigO(c)$
                \State $i++$                                        \Comment $\bigO(c)$
            \EndWhile
            \State $partida.cantMov \gets 0$                        \Comment $\bigO(1)$

            \State $idChocolate \gets mapa.idChocolate(m, partida.jugador)$             \Comment $\bigO(1)$
            \State $hayUnChocolate \gets 0 \leq idChocolate < mapa.cantChocolates(m)$   \Comment $\bigO(1)$
            \If{$hayUnChocolate$}                                                       \Comment $\bigO(1)$
                \State $partida.chocolates[idChocolate] \gets false$                    \Comment $\bigO(1)$
                \State $partida.inmunidad \gets 10$                                     \Comment $\bigO(1)$
            \Else
                \State $partida.inmunidad \gets 0$                                      \Comment $\bigO(1)$
            \EndIf

            \State $partida.perdio \gets mapa.esCasilleroPeligroso(m, partida.jugador) \wedge partida.inmunidad = 0$    \Comment $O(1)$
            \State $partida.gano \gets false$                                               \Comment $O(1)$

            \State $res \gets partida$                              \Comment $O(1)$

            \medskip
            \Statex
            \underline{Complejdad:} $\bigO(c)$
            \Statex
            \underline{Justificación:} La complejidad de este algoritmo es igual a recorrer el array $partida.chocolates$, que tiene longitud $c$, que es igual a la cantida de chocolates que contiene el mapa, para inicializar sus valores en $true$
            \end{algorithmic}
    \end{algorithm}

    \newpage

    \begin{algorithm}[H]{\textbf{iMover}(\Inout{p}{partida}, \In{d}{direccion})}
        \begin{algorithmic}[1]
                \If{$d = ARRIBA$}                                                           \Comment $\bigO(1)$
                    \State $desplazamiento \gets (0,1)$                                     \Comment $\bigO(1)$
                \EndIf
                \If{$d = ABAJO$}                                                            \Comment $\bigO(1)$
                    \State $desplazamiento \gets (0,-1)$                                    \Comment $\bigO(1)$
                \EndIf
                \If{$d = IZQUIERDA$}                                                        \Comment $\bigO(1)$
                    \State $desplazamiento \gets (-1,0)$                                    \Comment $\bigO(1)$
                \EndIf
                \If{$d = DERECHA$}                                                          \Comment $\bigO(1)$
                    \State $desplazamiento \gets (1,0)$                                     \Comment $\bigO(1)$
                \EndIf

                \State $nuevaPosicion \gets p.jugador + desplazamiento$                     \Comment $\bigO(1)$

                \If{$\neg mapa.esPared(p.mapa, nuevaPosicion) \wedge mapa.enRango(p.mapa, nuevaPosicion)$}  \Comment $\bigO(1)$
                    \State $p.jugador \gets nuevaPosicion$                                                     \Comment $\bigO(1)$
                    \State $p.cantMov++$                                                                    \Comment $\bigO(1)$

                    \State $idChocolate \gets mapa.idChocolate(p.mapa, p.jugador)$                          \Comment $\bigO(1)$
                    \State $hayUnChocolate \gets 0 \leq idChocolate < mapa.cantChocolates(p.mapa)$          \Comment $\bigO(1)$

                    \If{$hayUnChocolate \wedge_L p.chocolates[idChocolate]$}                                \Comment $\bigO(1)$
                        \State $p.chocolates[idChocolate] \gets false$                                      \Comment $\bigO(1)$
                        \State $p.inmunidad \gets 10$                                                       \Comment $\bigO(1)$
                    \Else
                        \State $p.inmunidad \gets max(p.inmunidad - 1, 0)$                                  \Comment $\bigO(1)$
                    \EndIf

                    \State $partida.perdio \gets mapa.esCasilleroPeligroso(m, partida.jugador) \wedge partida.inmunidad = 0$    \Comment $\bigO(1)$
                    \State $partida.gano \gets mapa.llegada(m) = partida.jugador$                                               \Comment $\bigO(1)$

                \EndIf

                \medskip
                \Statex \underline{Complejidad:} $\bigO(1)$
                \Statex \underline{Justificación:} No se recorre ninguna array, solo se accede a indices especificios. Los datos que provee el mapa, se encuentran guardados en arrays, que se complejidad de acceso es $\bigO(1)$, igualmente el acceso y modificación del array $partida.chocolates$ es $\bigO(1)$
            \end{algorithmic}
    \end{algorithm}
        

    \begin{algorithm}[H]{\textbf{iGanó?}(\In{p}{partida}) $\to$ $res$ : $bool$}
        \begin{algorithmic}[1]
                \State $res \gets p.gano$                                                                   \Comment $\Theta(1)$

                \medskip
                \Statex \underline{Complejidad:} $\Theta(1)$
            \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}[H]{\textbf{iPerdió?}(\In{p}{partida}) $\to$ $res$ : $bool$}
        \begin{algorithmic}[1]
                \State $res \gets p.perdio$                                                                 \Comment $\Theta(1)$

                \medskip
                \Statex \underline{Complejidad:} $\Theta(1)$
            \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}[H]{\textbf{iJugador}(\In{p}{partida}) $\to$ $res$ : $coordenada$}
        \begin{algorithmic}[1]
                \State $res \gets p.jugador$                                                               \Comment $\Theta(1)$

                \medskip
                \Statex \underline{Complejidad:} $\Theta(1)$
            \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}[H]{\textbf{iCantMov}(\In{p}{partida}) $\to$ $res$ : $nat$}
        \begin{algorithmic}[1]
                \State $res \gets p.cantMov$                                                                \Comment $\Theta(1)$

                \medskip
                \Statex \underline{Complejidad:} $\Theta(1)$
            \end{algorithmic}
    \end{algorithm}

\end{Algoritmos}
\end{document}